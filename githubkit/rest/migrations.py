"""DO NOT EDIT THIS FILE!

This file is automatically @generated by githubkit using the follow command:

    python -m codegen && isort . && black .

See https://github.com/github/rest-api-description for more information.
"""


from typing import TYPE_CHECKING, Dict, List, Union, Literal, Optional, overload

from pydantic import BaseModel, TypeAdapter

from githubkit.utils import UNSET, Missing, exclude_unset

from .types import (
    UserMigrationsPostBodyType,
    OrgsOrgMigrationsPostBodyType,
    ReposOwnerRepoImportPutBodyType,
    ReposOwnerRepoImportPatchBodyType,
    ReposOwnerRepoImportLfsPatchBodyType,
    ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType,
)
from .models import (
    Import,
    Migration,
    BasicError,
    PorterAuthor,
    PorterLargeFile,
    ValidationError,
    MinimalRepository,
    UserMigrationsPostBody,
    OrgsOrgMigrationsPostBody,
    ReposOwnerRepoImportPutBody,
    ReposOwnerRepoImportPatchBody,
    ReposOwnerRepoImportLfsPatchBody,
    ReposOwnerRepoImportAuthorsAuthorIdPatchBody,
)

if TYPE_CHECKING:
    from githubkit import GitHubCore
    from githubkit.response import Response


class MigrationsClient:
    _REST_API_VERSION = "2022-11-28"

    def __init__(self, github: "GitHubCore"):
        self._github = github

    def list_for_org(
        self,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Migration]]":
        url = f"/orgs/{org}/migrations"

        params = {
            "per_page": per_page,
            "page": page,
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Migration],
        )

    async def async_list_for_org(
        self,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Migration]]":
        url = f"/orgs/{org}/migrations"

        params = {
            "per_page": per_page,
            "page": page,
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Migration],
        )

    @overload
    def start_for_org(
        self,
        org: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: OrgsOrgMigrationsPostBodyType,
    ) -> "Response[Migration]":
        ...

    @overload
    def start_for_org(
        self,
        org: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        repositories: List[str],
        lock_repositories: Missing[bool] = False,
        exclude_metadata: Missing[bool] = False,
        exclude_git_data: Missing[bool] = False,
        exclude_attachments: Missing[bool] = False,
        exclude_releases: Missing[bool] = False,
        exclude_owner_projects: Missing[bool] = False,
        org_metadata_only: Missing[bool] = False,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
    ) -> "Response[Migration]":
        ...

    def start_for_org(
        self,
        org: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[OrgsOrgMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Migration]":
        url = f"/orgs/{org}/migrations"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(OrgsOrgMigrationsPostBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_start_for_org(
        self,
        org: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: OrgsOrgMigrationsPostBodyType,
    ) -> "Response[Migration]":
        ...

    @overload
    async def async_start_for_org(
        self,
        org: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        repositories: List[str],
        lock_repositories: Missing[bool] = False,
        exclude_metadata: Missing[bool] = False,
        exclude_git_data: Missing[bool] = False,
        exclude_attachments: Missing[bool] = False,
        exclude_releases: Missing[bool] = False,
        exclude_owner_projects: Missing[bool] = False,
        org_metadata_only: Missing[bool] = False,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
    ) -> "Response[Migration]":
        ...

    async def async_start_for_org(
        self,
        org: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[OrgsOrgMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Migration]":
        url = f"/orgs/{org}/migrations"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(OrgsOrgMigrationsPostBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    def get_status_for_org(
        self,
        org: str,
        migration_id: int,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Migration]":
        url = f"/orgs/{org}/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
            },
        )

    async def async_get_status_for_org(
        self,
        org: str,
        migration_id: int,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Migration]":
        url = f"/orgs/{org}/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
            },
        )

    def download_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_download_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def delete_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_delete_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def unlock_repo_for_org(
        self,
        org: str,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_unlock_repo_for_org(
        self,
        org: str,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def list_repos_for_org(
        self,
        org: str,
        migration_id: int,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/orgs/{org}/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_repos_for_org(
        self,
        org: str,
        migration_id: int,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/orgs/{org}/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    def get_import_status(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    async def async_get_import_status(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: ReposOwnerRepoImportPutBodyType,
    ) -> "Response[Import]":
        ...

    @overload
    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        vcs_url: str,
        vcs: Missing[Literal["subversion", "git", "mercurial", "tfvc"]] = UNSET,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> "Response[Import]":
        ...

    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(ReposOwnerRepoImportPutBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: ReposOwnerRepoImportPutBodyType,
    ) -> "Response[Import]":
        ...

    @overload
    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        vcs_url: str,
        vcs: Missing[Literal["subversion", "git", "mercurial", "tfvc"]] = UNSET,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> "Response[Import]":
        ...

    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(ReposOwnerRepoImportPutBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    def cancel_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "503": BasicError,
            },
        )

    async def async_cancel_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "503": BasicError,
            },
        )

    @overload
    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
    ) -> "Response[Import]":
        ...

    @overload
    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        vcs: Missing[Literal["subversion", "tfvc", "git", "mercurial"]] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> "Response[Import]":
        ...

    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(Union[ReposOwnerRepoImportPatchBody, None]).validate_python(
            json
        )
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "503": BasicError,
            },
        )

    @overload
    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
    ) -> "Response[Import]":
        ...

    @overload
    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        vcs: Missing[Literal["subversion", "tfvc", "git", "mercurial"]] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> "Response[Import]":
        ...

    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(Union[ReposOwnerRepoImportPatchBody, None]).validate_python(
            json
        )
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "503": BasicError,
            },
        )

    def get_commit_authors(
        self,
        owner: str,
        repo: str,
        since: Missing[int] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[PorterAuthor]]":
        url = f"/repos/{owner}/{repo}/import/authors"

        params = {
            "since": since,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[PorterAuthor],
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    async def async_get_commit_authors(
        self,
        owner: str,
        repo: str,
        since: Missing[int] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[PorterAuthor]]":
        url = f"/repos/{owner}/{repo}/import/authors"

        params = {
            "since": since,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[PorterAuthor],
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
    ) -> "Response[PorterAuthor]":
        ...

    @overload
    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        email: Missing[str] = UNSET,
        name: Missing[str] = UNSET,
    ) -> "Response[PorterAuthor]":
        ...

    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[PorterAuthor]":
        url = f"/repos/{owner}/{repo}/import/authors/{author_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(
            ReposOwnerRepoImportAuthorsAuthorIdPatchBody
        ).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=PorterAuthor,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
    ) -> "Response[PorterAuthor]":
        ...

    @overload
    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        email: Missing[str] = UNSET,
        name: Missing[str] = UNSET,
    ) -> "Response[PorterAuthor]":
        ...

    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[PorterAuthor]":
        url = f"/repos/{owner}/{repo}/import/authors/{author_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(
            ReposOwnerRepoImportAuthorsAuthorIdPatchBody
        ).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=PorterAuthor,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    def get_large_files(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[PorterLargeFile]]":
        url = f"/repos/{owner}/{repo}/import/large_files"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=List[PorterLargeFile],
            error_models={
                "503": BasicError,
            },
        )

    async def async_get_large_files(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[PorterLargeFile]]":
        url = f"/repos/{owner}/{repo}/import/large_files"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=List[PorterLargeFile],
            error_models={
                "503": BasicError,
            },
        )

    @overload
    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: ReposOwnerRepoImportLfsPatchBodyType,
    ) -> "Response[Import]":
        ...

    @overload
    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        use_lfs: Literal["opt_in", "opt_out"],
    ) -> "Response[Import]":
        ...

    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportLfsPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import/lfs"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(ReposOwnerRepoImportLfsPatchBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "503": BasicError,
            },
        )

    @overload
    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: ReposOwnerRepoImportLfsPatchBodyType,
    ) -> "Response[Import]":
        ...

    @overload
    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        use_lfs: Literal["opt_in", "opt_out"],
    ) -> "Response[Import]":
        ...

    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportLfsPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Import]":
        url = f"/repos/{owner}/{repo}/import/lfs"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(ReposOwnerRepoImportLfsPatchBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "503": BasicError,
            },
        )

    def list_for_authenticated_user(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Migration]]":
        url = "/user/migrations"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Migration],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_list_for_authenticated_user(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Migration]]":
        url = "/user/migrations"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Migration],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    def start_for_authenticated_user(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: UserMigrationsPostBodyType,
    ) -> "Response[Migration]":
        ...

    @overload
    def start_for_authenticated_user(
        self,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = False,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        repositories: List[str],
    ) -> "Response[Migration]":
        ...

    def start_for_authenticated_user(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[UserMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Migration]":
        url = "/user/migrations"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(UserMigrationsPostBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "422": ValidationError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    async def async_start_for_authenticated_user(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: UserMigrationsPostBodyType,
    ) -> "Response[Migration]":
        ...

    @overload
    async def async_start_for_authenticated_user(
        self,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = False,
        exclude: Missing[List[Literal["repositories"]]] = UNSET,
        repositories: List[str],
    ) -> "Response[Migration]":
        ...

    async def async_start_for_authenticated_user(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[UserMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Migration]":
        url = "/user/migrations"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = TypeAdapter(UserMigrationsPostBody).validate_python(json)
        json = json.model_dump(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "422": ValidationError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def get_status_for_authenticated_user(
        self,
        migration_id: int,
        exclude: Missing[List[str]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Migration]":
        url = f"/user/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_status_for_authenticated_user(
        self,
        migration_id: int,
        exclude: Missing[List[str]] = UNSET,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Migration]":
        url = f"/user/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def get_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def delete_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_delete_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def unlock_repo_for_authenticated_user(
        self,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_unlock_repo_for_authenticated_user(
        self,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def list_repos_for_authenticated_user(
        self,
        migration_id: int,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/user/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_repos_for_authenticated_user(
        self,
        migration_id: int,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/user/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )
