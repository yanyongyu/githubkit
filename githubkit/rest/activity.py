"""DO NOT EDIT THIS FILE!

This file is automatically @generated by githubkit using the follow command:

    python -m codegen && isort . && black .

See https://github.com/github/rest-api-description for more information.
"""


from datetime import datetime
from typing import TYPE_CHECKING, Dict, List, Union, Literal, Optional, overload

from pydantic import BaseModel, parse_obj_as

from githubkit.utils import UNSET, Missing, exclude_unset

from .types import (
    NotificationsPutBodyType,
    ReposOwnerRepoSubscriptionPutBodyType,
    ReposOwnerRepoNotificationsPutBodyType,
    NotificationsThreadsThreadIdSubscriptionPutBodyType,
)
from .models import (
    Feed,
    Event,
    Thread,
    Stargazer,
    BasicError,
    Repository,
    SimpleUser,
    ValidationError,
    MinimalRepository,
    StarredRepository,
    ThreadSubscription,
    NotificationsPutBody,
    RepositorySubscription,
    NotificationsPutResponse202,
    ReposOwnerRepoSubscriptionPutBody,
    ReposOwnerRepoNotificationsPutBody,
    ReposOwnerRepoNotificationsPutResponse202,
    NotificationsThreadsThreadIdSubscriptionPutBody,
    EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
)

if TYPE_CHECKING:
    from githubkit import GitHubCore
    from githubkit.response import Response


class ActivityClient:
    _REST_API_VERSION = "2022-11-28"

    def __init__(self, github: "GitHubCore"):
        self._github = github

    def list_public_events(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = "/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
            error_models={
                "403": BasicError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
            },
        )

    async def async_list_public_events(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = "/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
            error_models={
                "403": BasicError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
            },
        )

    def get_feeds(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Feed]":
        url = "/feeds"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Feed,
        )

    async def async_get_feeds(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Feed]":
        url = "/feeds"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Feed,
        )

    def list_public_events_for_repo_network(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/networks/{owner}/{repo}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
            error_models={
                "404": BasicError,
                "403": BasicError,
            },
        )

    async def async_list_public_events_for_repo_network(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/networks/{owner}/{repo}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
            error_models={
                "404": BasicError,
                "403": BasicError,
            },
        )

    def list_notifications_for_authenticated_user(
        self,
        all_: Missing[bool] = False,
        participating: Missing[bool] = False,
        since: Missing[datetime] = UNSET,
        before: Missing[datetime] = UNSET,
        page: Missing[int] = 1,
        per_page: Missing[int] = 50,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Thread]]":
        url = "/notifications"

        params = {
            "all": all_,
            "participating": participating,
            "since": since,
            "before": before,
            "page": page,
            "per_page": per_page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Thread],
            error_models={
                "403": BasicError,
                "401": BasicError,
                "422": ValidationError,
            },
        )

    async def async_list_notifications_for_authenticated_user(
        self,
        all_: Missing[bool] = False,
        participating: Missing[bool] = False,
        since: Missing[datetime] = UNSET,
        before: Missing[datetime] = UNSET,
        page: Missing[int] = 1,
        per_page: Missing[int] = 50,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Thread]]":
        url = "/notifications"

        params = {
            "all": all_,
            "participating": participating,
            "since": since,
            "before": before,
            "page": page,
            "per_page": per_page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Thread],
            error_models={
                "403": BasicError,
                "401": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    def mark_notifications_as_read(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsPutBodyType] = UNSET,
    ) -> "Response[NotificationsPutResponse202]":
        ...

    @overload
    def mark_notifications_as_read(
        self,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        last_read_at: Missing[datetime] = UNSET,
        read: Missing[bool] = UNSET,
    ) -> "Response[NotificationsPutResponse202]":
        ...

    def mark_notifications_as_read(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[NotificationsPutResponse202]":
        url = "/notifications"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(NotificationsPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=NotificationsPutResponse202,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    async def async_mark_notifications_as_read(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsPutBodyType] = UNSET,
    ) -> "Response[NotificationsPutResponse202]":
        ...

    @overload
    async def async_mark_notifications_as_read(
        self,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        last_read_at: Missing[datetime] = UNSET,
        read: Missing[bool] = UNSET,
    ) -> "Response[NotificationsPutResponse202]":
        ...

    async def async_mark_notifications_as_read(
        self,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[NotificationsPutResponse202]":
        url = "/notifications"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(NotificationsPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=NotificationsPutResponse202,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def get_thread(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Thread]":
        url = f"/notifications/threads/{thread_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Thread,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_thread(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Thread]":
        url = f"/notifications/threads/{thread_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Thread,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def mark_thread_as_read(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/notifications/threads/{thread_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "PATCH",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
            },
        )

    async def async_mark_thread_as_read(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/notifications/threads/{thread_id}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "PATCH",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
            },
        )

    def get_thread_subscription_for_authenticated_user(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[ThreadSubscription]":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=ThreadSubscription,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_thread_subscription_for_authenticated_user(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[ThreadSubscription]":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=ThreadSubscription,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    def set_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsThreadsThreadIdSubscriptionPutBodyType] = UNSET,
    ) -> "Response[ThreadSubscription]":
        ...

    @overload
    def set_thread_subscription(
        self,
        thread_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        ignored: Missing[bool] = False,
    ) -> "Response[ThreadSubscription]":
        ...

    def set_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsThreadsThreadIdSubscriptionPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[ThreadSubscription]":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(NotificationsThreadsThreadIdSubscriptionPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=ThreadSubscription,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    async def async_set_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsThreadsThreadIdSubscriptionPutBodyType] = UNSET,
    ) -> "Response[ThreadSubscription]":
        ...

    @overload
    async def async_set_thread_subscription(
        self,
        thread_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        ignored: Missing[bool] = False,
    ) -> "Response[ThreadSubscription]":
        ...

    async def async_set_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[NotificationsThreadsThreadIdSubscriptionPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[ThreadSubscription]":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(NotificationsThreadsThreadIdSubscriptionPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=ThreadSubscription,
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def delete_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_delete_thread_subscription(
        self,
        thread_id: int,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/notifications/threads/{thread_id}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def list_public_org_events(
        self,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/orgs/{org}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_public_org_events(
        self,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/orgs/{org}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_repo_events(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/repos/{owner}/{repo}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_repo_events(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/repos/{owner}/{repo}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_repo_notifications_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        all_: Missing[bool] = False,
        participating: Missing[bool] = False,
        since: Missing[datetime] = UNSET,
        before: Missing[datetime] = UNSET,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Thread]]":
        url = f"/repos/{owner}/{repo}/notifications"

        params = {
            "all": all_,
            "participating": participating,
            "since": since,
            "before": before,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Thread],
        )

    async def async_list_repo_notifications_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        all_: Missing[bool] = False,
        participating: Missing[bool] = False,
        since: Missing[datetime] = UNSET,
        before: Missing[datetime] = UNSET,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Thread]]":
        url = f"/repos/{owner}/{repo}/notifications"

        params = {
            "all": all_,
            "participating": participating,
            "since": since,
            "before": before,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Thread],
        )

    @overload
    def mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoNotificationsPutBodyType] = UNSET,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        ...

    @overload
    def mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        last_read_at: Missing[datetime] = UNSET,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        ...

    def mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoNotificationsPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        url = f"/repos/{owner}/{repo}/notifications"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoNotificationsPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=ReposOwnerRepoNotificationsPutResponse202,
        )

    @overload
    async def async_mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoNotificationsPutBodyType] = UNSET,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        ...

    @overload
    async def async_mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        last_read_at: Missing[datetime] = UNSET,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        ...

    async def async_mark_repo_notifications_as_read(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoNotificationsPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[ReposOwnerRepoNotificationsPutResponse202]":
        url = f"/repos/{owner}/{repo}/notifications"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoNotificationsPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=ReposOwnerRepoNotificationsPutResponse202,
        )

    def list_stargazers_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Union[List[SimpleUser], List[Stargazer]]]":
        url = f"/repos/{owner}/{repo}/stargazers"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Union[List[SimpleUser], List[Stargazer]],
            error_models={
                "422": ValidationError,
            },
        )

    async def async_list_stargazers_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Union[List[SimpleUser], List[Stargazer]]]":
        url = f"/repos/{owner}/{repo}/stargazers"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Union[List[SimpleUser], List[Stargazer]],
            error_models={
                "422": ValidationError,
            },
        )

    def list_watchers_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[SimpleUser]]":
        url = f"/repos/{owner}/{repo}/subscribers"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[SimpleUser],
        )

    async def async_list_watchers_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[SimpleUser]]":
        url = f"/repos/{owner}/{repo}/subscribers"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[SimpleUser],
        )

    def get_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[RepositorySubscription]":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=RepositorySubscription,
            error_models={
                "403": BasicError,
            },
        )

    async def async_get_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[RepositorySubscription]":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=RepositorySubscription,
            error_models={
                "403": BasicError,
            },
        )

    @overload
    def set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoSubscriptionPutBodyType] = UNSET,
    ) -> "Response[RepositorySubscription]":
        ...

    @overload
    def set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        subscribed: Missing[bool] = UNSET,
        ignored: Missing[bool] = UNSET,
    ) -> "Response[RepositorySubscription]":
        ...

    def set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoSubscriptionPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[RepositorySubscription]":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoSubscriptionPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=RepositorySubscription,
        )

    @overload
    async def async_set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoSubscriptionPutBodyType] = UNSET,
    ) -> "Response[RepositorySubscription]":
        ...

    @overload
    async def async_set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        headers: Optional[Dict[str, str]] = None,
        subscribed: Missing[bool] = UNSET,
        ignored: Missing[bool] = UNSET,
    ) -> "Response[RepositorySubscription]":
        ...

    async def async_set_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
        data: Missing[ReposOwnerRepoSubscriptionPutBodyType] = UNSET,
        **kwargs,
    ) -> "Response[RepositorySubscription]":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoSubscriptionPutBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=RepositorySubscription,
        )

    def delete_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    async def async_delete_repo_subscription(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/subscription"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    def list_repos_starred_by_authenticated_user(
        self,
        sort: Missing[Literal["created", "updated"]] = "created",
        direction: Missing[Literal["asc", "desc"]] = "desc",
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Repository]]":
        url = "/user/starred"

        params = {
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Repository],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_list_repos_starred_by_authenticated_user(
        self,
        sort: Missing[Literal["created", "updated"]] = "created",
        direction: Missing[Literal["asc", "desc"]] = "desc",
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Repository]]":
        url = "/user/starred"

        params = {
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Repository],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def check_repo_is_starred_by_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "401": BasicError,
                "403": BasicError,
            },
        )

    async def async_check_repo_is_starred_by_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "401": BasicError,
                "403": BasicError,
            },
        )

    def star_repo_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "PUT",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "404": BasicError,
                "401": BasicError,
            },
        )

    async def async_star_repo_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "PUT",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "404": BasicError,
                "401": BasicError,
            },
        )

    def unstar_repo_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "401": BasicError,
                "403": BasicError,
            },
        )

    async def async_unstar_repo_for_authenticated_user(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response":
        url = f"/user/starred/{owner}/{repo}"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "401": BasicError,
                "403": BasicError,
            },
        )

    def list_watched_repos_for_authenticated_user(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = "/user/subscriptions"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_list_watched_repos_for_authenticated_user(
        self,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = "/user/subscriptions"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def list_events_for_authenticated_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_events_for_authenticated_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_org_events_for_authenticated_user(
        self,
        username: str,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events/orgs/{org}"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_org_events_for_authenticated_user(
        self,
        username: str,
        org: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events/orgs/{org}"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_public_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events/public"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_public_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/events/public"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_received_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/received_events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_received_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/received_events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_received_public_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/received_events/public"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    async def async_list_received_public_events_for_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[Event]]":
        url = f"/users/{username}/received_events/public"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Event],
        )

    def list_repos_starred_by_user(
        self,
        username: str,
        sort: Missing[Literal["created", "updated"]] = "created",
        direction: Missing[Literal["asc", "desc"]] = "desc",
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Union[List[StarredRepository], List[Repository]]]":
        url = f"/users/{username}/starred"

        params = {
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Union[List[StarredRepository], List[Repository]],
        )

    async def async_list_repos_starred_by_user(
        self,
        username: str,
        sort: Missing[Literal["created", "updated"]] = "created",
        direction: Missing[Literal["asc", "desc"]] = "desc",
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[Union[List[StarredRepository], List[Repository]]]":
        url = f"/users/{username}/starred"

        params = {
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Union[List[StarredRepository], List[Repository]],
        )

    def list_repos_watched_by_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/users/{username}/subscriptions"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
        )

    async def async_list_repos_watched_by_user(
        self,
        username: str,
        per_page: Missing[int] = 30,
        page: Missing[int] = 1,
        *,
        headers: Optional[Dict[str, str]] = None,
    ) -> "Response[List[MinimalRepository]]":
        url = f"/users/{username}/subscriptions"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[MinimalRepository],
        )
