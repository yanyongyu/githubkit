"""DO NOT EDIT THIS FILE!

This file is automatically @generated by githubkit using the follow command:

    python -m codegen && isort . && black .

See https://github.com/github/rest-api-description for more information.
"""


from datetime import datetime
from typing import TYPE_CHECKING, List, Union, Literal, overload

from pydantic import BaseModel, parse_obj_as

from githubkit.utils import UNSET, MISSING, exclude_unset

from .types import (
    ReposOwnerRepoIssuesPostBodyType,
    ReposOwnerRepoLabelsPostBodyType,
    ReposOwnerRepoMilestonesPostBodyType,
    ReposOwnerRepoLabelsNamePatchBodyType,
    ReposOwnerRepoIssuesIssueNumberPatchBodyType,
    ReposOwnerRepoIssuesIssueNumberLockPutBodyType,
    ReposOwnerRepoIssuesCommentsCommentIdPatchBodyType,
    ReposOwnerRepoIssuesIssueNumberCommentsPostBodyType,
    ReposOwnerRepoIssuesIssueNumberAssigneesPostBodyType,
    ReposOwnerRepoMilestonesMilestoneNumberPatchBodyType,
    ReposOwnerRepoIssuesPostBodyPropLabelsItemsOneof1Type,
    ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBodyType,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0Type,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2Type,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0Type,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2Type,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3ItemsType,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3ItemsType,
    ReposOwnerRepoIssuesIssueNumberPatchBodyPropLabelsItemsOneof1Type,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2PropLabelsItemsType,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2PropLabelsItemsType,
)
from .models import (
    Issue,
    Label,
    Milestone,
    BasicError,
    IssueEvent,
    SimpleUser,
    IssueComment,
    ValidationError,
    LockedIssueEvent,
    LabeledIssueEvent,
    RenamedIssueEvent,
    AssignedIssueEvent,
    UnlabeledIssueEvent,
    MilestonedIssueEvent,
    TimelineCommentEvent,
    UnassignedIssueEvent,
    StateChangeIssueEvent,
    TimelineReviewedEvent,
    DemilestonedIssueEvent,
    TimelineCommittedEvent,
    AddedToProjectIssueEvent,
    ReviewDismissedIssueEvent,
    ReviewRequestedIssueEvent,
    TimelineAssignedIssueEvent,
    TimelineLineCommentedEvent,
    RemovedFromProjectIssueEvent,
    ReposOwnerRepoIssuesPostBody,
    ReposOwnerRepoLabelsPostBody,
    TimelineCommitCommentedEvent,
    TimelineCrossReferencedEvent,
    TimelineUnassignedIssueEvent,
    ConvertedNoteToIssueIssueEvent,
    MovedColumnInProjectIssueEvent,
    ReviewRequestRemovedIssueEvent,
    ReposOwnerRepoMilestonesPostBody,
    ReposOwnerRepoLabelsNamePatchBody,
    ReposOwnerRepoIssuesIssueNumberPatchBody,
    ReposOwnerRepoIssuesIssueNumberLockPutBody,
    ReposOwnerRepoIssuesCommentsCommentIdPatchBody,
    ReposOwnerRepoIssuesIssueNumberCommentsPostBody,
    ReposOwnerRepoIssuesIssueNumberAssigneesPostBody,
    ReposOwnerRepoMilestonesMilestoneNumberPatchBody,
    ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBody,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2,
    EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
    ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3Items,
    ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3Items,
)

if TYPE_CHECKING:
    from githubkit import GitHubCore
    from githubkit.response import Response


class IssuesClient:
    _REST_API_VERSION = "2022-11-28"

    def __init__(self, github: "GitHubCore"):
        self._github = github

    def list(
        self,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        collab: MISSING[bool] = UNSET,
        orgs: MISSING[bool] = UNSET,
        owned: MISSING[bool] = UNSET,
        pulls: MISSING[bool] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = "/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "collab": collab,
            "orgs": orgs,
            "owned": owned,
            "pulls": pulls,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    async def async_list(
        self,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        collab: MISSING[bool] = UNSET,
        orgs: MISSING[bool] = UNSET,
        owned: MISSING[bool] = UNSET,
        pulls: MISSING[bool] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = "/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "collab": collab,
            "orgs": orgs,
            "owned": owned,
            "pulls": pulls,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    def list_for_org(
        self,
        org: str,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = f"/orgs/{org}/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_for_org(
        self,
        org: str,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = f"/orgs/{org}/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "404": BasicError,
            },
        )

    def list_assignees(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[SimpleUser]]":
        url = f"/repos/{owner}/{repo}/assignees"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[SimpleUser],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_assignees(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[SimpleUser]]":
        url = f"/repos/{owner}/{repo}/assignees"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[SimpleUser],
            error_models={
                "404": BasicError,
            },
        )

    def check_user_can_be_assigned(
        self,
        owner: str,
        repo: str,
        assignee: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/assignees/{assignee}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_check_user_can_be_assigned(
        self,
        owner: str,
        repo: str,
        assignee: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/assignees/{assignee}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def list_for_repo(
        self,
        owner: str,
        repo: str,
        milestone: MISSING[str] = UNSET,
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        assignee: MISSING[str] = UNSET,
        creator: MISSING[str] = UNSET,
        mentioned: MISSING[str] = UNSET,
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = f"/repos/{owner}/{repo}/issues"

        params = {
            "milestone": milestone,
            "state": state,
            "assignee": assignee,
            "creator": creator,
            "mentioned": mentioned,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    async def async_list_for_repo(
        self,
        owner: str,
        repo: str,
        milestone: MISSING[str] = UNSET,
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        assignee: MISSING[str] = UNSET,
        creator: MISSING[str] = UNSET,
        mentioned: MISSING[str] = UNSET,
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = f"/repos/{owner}/{repo}/issues"

        params = {
            "milestone": milestone,
            "state": state,
            "assignee": assignee,
            "creator": creator,
            "mentioned": mentioned,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    @overload
    def create(
        self, owner: str, repo: str, *, data: ReposOwnerRepoIssuesPostBodyType
    ) -> "Response[Issue]":
        ...

    @overload
    def create(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        title: Union[str, int],
        body: MISSING[str] = UNSET,
        assignee: MISSING[Union[str, None]] = UNSET,
        milestone: MISSING[Union[str, int, None]] = UNSET,
        labels: MISSING[
            List[Union[str, ReposOwnerRepoIssuesPostBodyPropLabelsItemsOneof1Type]]
        ] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    def create(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoIssuesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "403": BasicError,
                "422": ValidationError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    async def async_create(
        self, owner: str, repo: str, *, data: ReposOwnerRepoIssuesPostBodyType
    ) -> "Response[Issue]":
        ...

    @overload
    async def async_create(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        title: Union[str, int],
        body: MISSING[str] = UNSET,
        assignee: MISSING[Union[str, None]] = UNSET,
        milestone: MISSING[Union[str, int, None]] = UNSET,
        labels: MISSING[
            List[Union[str, ReposOwnerRepoIssuesPostBodyPropLabelsItemsOneof1Type]]
        ] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    async def async_create(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoIssuesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "403": BasicError,
                "422": ValidationError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
                "404": BasicError,
                "410": BasicError,
            },
        )

    def list_comments_for_repo(
        self,
        owner: str,
        repo: str,
        sort: MISSING[Literal["created", "updated"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = UNSET,
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueComment]]":
        url = f"/repos/{owner}/{repo}/issues/comments"

        params = {
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueComment],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    async def async_list_comments_for_repo(
        self,
        owner: str,
        repo: str,
        sort: MISSING[Literal["created", "updated"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = UNSET,
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueComment]]":
        url = f"/repos/{owner}/{repo}/issues/comments"

        params = {
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueComment],
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    def get_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "404": BasicError,
            },
        )

    async def async_get_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "404": BasicError,
            },
        )

    def delete_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    async def async_delete_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    @overload
    def update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: ReposOwnerRepoIssuesCommentsCommentIdPatchBodyType,
    ) -> "Response[IssueComment]":
        ...

    @overload
    def update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        body: str,
    ) -> "Response[IssueComment]":
        ...

    def update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesCommentsCommentIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesCommentsCommentIdPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "422": ValidationError,
            },
        )

    @overload
    async def async_update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: ReposOwnerRepoIssuesCommentsCommentIdPatchBodyType,
    ) -> "Response[IssueComment]":
        ...

    @overload
    async def async_update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: Literal[UNSET] = UNSET,
        body: str,
    ) -> "Response[IssueComment]":
        ...

    async def async_update_comment(
        self,
        owner: str,
        repo: str,
        comment_id: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesCommentsCommentIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/comments/{comment_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesCommentsCommentIdPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "422": ValidationError,
            },
        )

    def list_events_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueEvent]]":
        url = f"/repos/{owner}/{repo}/issues/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueEvent],
            error_models={
                "422": ValidationError,
            },
        )

    async def async_list_events_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueEvent]]":
        url = f"/repos/{owner}/{repo}/issues/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueEvent],
            error_models={
                "422": ValidationError,
            },
        )

    def get_event(
        self,
        owner: str,
        repo: str,
        event_id: int,
    ) -> "Response[IssueEvent]":
        url = f"/repos/{owner}/{repo}/issues/events/{event_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=IssueEvent,
            error_models={
                "404": BasicError,
                "410": BasicError,
                "403": BasicError,
            },
        )

    async def async_get_event(
        self,
        owner: str,
        repo: str,
        event_id: int,
    ) -> "Response[IssueEvent]":
        url = f"/repos/{owner}/{repo}/issues/events/{event_id}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=IssueEvent,
            error_models={
                "404": BasicError,
                "410": BasicError,
                "403": BasicError,
            },
        )

    def get(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_get(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    def update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberPatchBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    def update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        title: MISSING[Union[str, int, None]] = UNSET,
        body: MISSING[Union[str, None]] = UNSET,
        assignee: MISSING[Union[str, None]] = UNSET,
        state: MISSING[Literal["open", "closed"]] = UNSET,
        state_reason: MISSING[
            Union[None, Literal["completed", "not_planned", "reopened"]]
        ] = UNSET,
        milestone: MISSING[Union[str, int, None]] = UNSET,
        labels: MISSING[
            List[
                Union[
                    str,
                    ReposOwnerRepoIssuesIssueNumberPatchBodyPropLabelsItemsOneof1Type,
                ]
            ]
        ] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    def update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "422": ValidationError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
                "403": BasicError,
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    async def async_update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberPatchBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    async def async_update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        title: MISSING[Union[str, int, None]] = UNSET,
        body: MISSING[Union[str, None]] = UNSET,
        assignee: MISSING[Union[str, None]] = UNSET,
        state: MISSING[Literal["open", "closed"]] = UNSET,
        state_reason: MISSING[
            Union[None, Literal["completed", "not_planned", "reopened"]]
        ] = UNSET,
        milestone: MISSING[Union[str, int, None]] = UNSET,
        labels: MISSING[
            List[
                Union[
                    str,
                    ReposOwnerRepoIssuesIssueNumberPatchBodyPropLabelsItemsOneof1Type,
                ]
            ]
        ] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    async def async_update(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
            error_models={
                "422": ValidationError,
                "503": EnterprisesEnterpriseSecretScanningAlertsGetResponse503,
                "403": BasicError,
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    def add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesPostBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    def add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    def add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberAssigneesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
        )

    @overload
    async def async_add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesPostBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    async def async_add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    async def async_add_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberAssigneesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
        )

    @overload
    def remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    def remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    def remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "DELETE",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
        )

    @overload
    async def async_remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBodyType] = UNSET,
    ) -> "Response[Issue]":
        ...

    @overload
    async def async_remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        assignees: MISSING[List[str]] = UNSET,
    ) -> "Response[Issue]":
        ...

    async def async_remove_assignees(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Issue]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberAssigneesDeleteBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "DELETE",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Issue,
        )

    def check_user_can_be_assigned_to_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        assignee: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_check_user_can_be_assigned_to_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        assignee: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def list_comments(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueComment]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/comments"

        params = {
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueComment],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_list_comments(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[IssueComment]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/comments"

        params = {
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[IssueComment],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    def create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: ReposOwnerRepoIssuesIssueNumberCommentsPostBodyType,
    ) -> "Response[IssueComment]":
        ...

    @overload
    def create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        body: str,
    ) -> "Response[IssueComment]":
        ...

    def create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberCommentsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/comments"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberCommentsPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "403": BasicError,
                "410": BasicError,
                "422": ValidationError,
                "404": BasicError,
            },
        )

    @overload
    async def async_create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: ReposOwnerRepoIssuesIssueNumberCommentsPostBodyType,
    ) -> "Response[IssueComment]":
        ...

    @overload
    async def async_create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        body: str,
    ) -> "Response[IssueComment]":
        ...

    async def async_create_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[ReposOwnerRepoIssuesIssueNumberCommentsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[IssueComment]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/comments"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoIssuesIssueNumberCommentsPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=IssueComment,
            error_models={
                "403": BasicError,
                "410": BasicError,
                "422": ValidationError,
                "404": BasicError,
            },
        )

    def list_events(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Union[LabeledIssueEvent, UnlabeledIssueEvent, AssignedIssueEvent, UnassignedIssueEvent, MilestonedIssueEvent, DemilestonedIssueEvent, RenamedIssueEvent, ReviewRequestedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewDismissedIssueEvent, LockedIssueEvent, AddedToProjectIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, ConvertedNoteToIssueIssueEvent]]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[
                Union[
                    LabeledIssueEvent,
                    UnlabeledIssueEvent,
                    AssignedIssueEvent,
                    UnassignedIssueEvent,
                    MilestonedIssueEvent,
                    DemilestonedIssueEvent,
                    RenamedIssueEvent,
                    ReviewRequestedIssueEvent,
                    ReviewRequestRemovedIssueEvent,
                    ReviewDismissedIssueEvent,
                    LockedIssueEvent,
                    AddedToProjectIssueEvent,
                    MovedColumnInProjectIssueEvent,
                    RemovedFromProjectIssueEvent,
                    ConvertedNoteToIssueIssueEvent,
                ]
            ],
            error_models={
                "410": BasicError,
            },
        )

    async def async_list_events(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Union[LabeledIssueEvent, UnlabeledIssueEvent, AssignedIssueEvent, UnassignedIssueEvent, MilestonedIssueEvent, DemilestonedIssueEvent, RenamedIssueEvent, ReviewRequestedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewDismissedIssueEvent, LockedIssueEvent, AddedToProjectIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, ConvertedNoteToIssueIssueEvent]]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/events"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[
                Union[
                    LabeledIssueEvent,
                    UnlabeledIssueEvent,
                    AssignedIssueEvent,
                    UnassignedIssueEvent,
                    MilestonedIssueEvent,
                    DemilestonedIssueEvent,
                    RenamedIssueEvent,
                    ReviewRequestedIssueEvent,
                    ReviewRequestRemovedIssueEvent,
                    ReviewDismissedIssueEvent,
                    LockedIssueEvent,
                    AddedToProjectIssueEvent,
                    MovedColumnInProjectIssueEvent,
                    RemovedFromProjectIssueEvent,
                    ConvertedNoteToIssueIssueEvent,
                ]
            ],
            error_models={
                "410": BasicError,
            },
        )

    def list_labels_on_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_list_labels_on_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    def set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    def set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[List[str]] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    def set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[
            List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2PropLabelsItemsType]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    def set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
        **kwargs,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3Items],
                str,
            ],
            json,
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    async def async_set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[List[str]] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    async def async_set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[
            List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2PropLabelsItemsType]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    async def async_set_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
        **kwargs,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof0,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof2,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPutBodyOneof3Items],
                str,
            ],
            json,
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    def add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    def add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[List[str]] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    def add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[
            List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2PropLabelsItemsType]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    def add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
        **kwargs,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3Items],
                str,
            ],
            json,
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    async def async_add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[List[str]] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    @overload
    async def async_add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        labels: MISSING[
            List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2PropLabelsItemsType]
        ] = UNSET,
    ) -> "Response[List[Label]]":
        ...

    async def async_add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0Type,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2Type,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3ItemsType],
                str,
            ]
        ] = UNSET,
        **kwargs,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof0,
                List[str],
                ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof2,
                List[ReposOwnerRepoIssuesIssueNumberLabelsPostBodyOneof3Items],
                str,
            ],
            json,
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
                "422": ValidationError,
            },
        )

    def remove_all_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_remove_all_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    def remove_label(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        name: str,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_remove_label(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        name: str,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    @overload
    def lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBodyType, None]
        ] = UNSET,
    ) -> "Response":
        ...

    @overload
    def lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        lock_reason: MISSING[
            Literal["off-topic", "too heated", "resolved", "spam"]
        ] = UNSET,
    ) -> "Response":
        ...

    def lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBodyType, None]
        ] = UNSET,
        **kwargs,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/lock"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBody, None], json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "410": BasicError,
                "404": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBodyType, None]
        ] = UNSET,
    ) -> "Response":
        ...

    @overload
    async def async_lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        lock_reason: MISSING[
            Literal["off-topic", "too heated", "resolved", "spam"]
        ] = UNSET,
    ) -> "Response":
        ...

    async def async_lock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        *,
        data: MISSING[
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBodyType, None]
        ] = UNSET,
        **kwargs,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/lock"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            Union[ReposOwnerRepoIssuesIssueNumberLockPutBody, None], json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "410": BasicError,
                "404": BasicError,
                "422": ValidationError,
            },
        )

    def unlock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/lock"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "404": BasicError,
            },
        )

    async def async_unlock(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/lock"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "404": BasicError,
            },
        )

    def list_events_for_timeline(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Union[LabeledIssueEvent, UnlabeledIssueEvent, MilestonedIssueEvent, DemilestonedIssueEvent, RenamedIssueEvent, ReviewRequestedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewDismissedIssueEvent, LockedIssueEvent, AddedToProjectIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, ConvertedNoteToIssueIssueEvent, TimelineCommentEvent, TimelineCrossReferencedEvent, TimelineCommittedEvent, TimelineReviewedEvent, TimelineLineCommentedEvent, TimelineCommitCommentedEvent, TimelineAssignedIssueEvent, TimelineUnassignedIssueEvent, StateChangeIssueEvent]]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/timeline"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[
                Union[
                    LabeledIssueEvent,
                    UnlabeledIssueEvent,
                    MilestonedIssueEvent,
                    DemilestonedIssueEvent,
                    RenamedIssueEvent,
                    ReviewRequestedIssueEvent,
                    ReviewRequestRemovedIssueEvent,
                    ReviewDismissedIssueEvent,
                    LockedIssueEvent,
                    AddedToProjectIssueEvent,
                    MovedColumnInProjectIssueEvent,
                    RemovedFromProjectIssueEvent,
                    ConvertedNoteToIssueIssueEvent,
                    TimelineCommentEvent,
                    TimelineCrossReferencedEvent,
                    TimelineCommittedEvent,
                    TimelineReviewedEvent,
                    TimelineLineCommentedEvent,
                    TimelineCommitCommentedEvent,
                    TimelineAssignedIssueEvent,
                    TimelineUnassignedIssueEvent,
                    StateChangeIssueEvent,
                ]
            ],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    async def async_list_events_for_timeline(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Union[LabeledIssueEvent, UnlabeledIssueEvent, MilestonedIssueEvent, DemilestonedIssueEvent, RenamedIssueEvent, ReviewRequestedIssueEvent, ReviewRequestRemovedIssueEvent, ReviewDismissedIssueEvent, LockedIssueEvent, AddedToProjectIssueEvent, MovedColumnInProjectIssueEvent, RemovedFromProjectIssueEvent, ConvertedNoteToIssueIssueEvent, TimelineCommentEvent, TimelineCrossReferencedEvent, TimelineCommittedEvent, TimelineReviewedEvent, TimelineLineCommentedEvent, TimelineCommitCommentedEvent, TimelineAssignedIssueEvent, TimelineUnassignedIssueEvent, StateChangeIssueEvent]]]":
        url = f"/repos/{owner}/{repo}/issues/{issue_number}/timeline"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[
                Union[
                    LabeledIssueEvent,
                    UnlabeledIssueEvent,
                    MilestonedIssueEvent,
                    DemilestonedIssueEvent,
                    RenamedIssueEvent,
                    ReviewRequestedIssueEvent,
                    ReviewRequestRemovedIssueEvent,
                    ReviewDismissedIssueEvent,
                    LockedIssueEvent,
                    AddedToProjectIssueEvent,
                    MovedColumnInProjectIssueEvent,
                    RemovedFromProjectIssueEvent,
                    ConvertedNoteToIssueIssueEvent,
                    TimelineCommentEvent,
                    TimelineCrossReferencedEvent,
                    TimelineCommittedEvent,
                    TimelineReviewedEvent,
                    TimelineLineCommentedEvent,
                    TimelineCommitCommentedEvent,
                    TimelineAssignedIssueEvent,
                    TimelineUnassignedIssueEvent,
                    StateChangeIssueEvent,
                ]
            ],
            error_models={
                "404": BasicError,
                "410": BasicError,
            },
        )

    def list_labels_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_labels_for_repo(
        self,
        owner: str,
        repo: str,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
            error_models={
                "404": BasicError,
            },
        )

    @overload
    def create_label(
        self, owner: str, repo: str, *, data: ReposOwnerRepoLabelsPostBodyType
    ) -> "Response[Label]":
        ...

    @overload
    def create_label(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        name: str,
        color: MISSING[str] = UNSET,
        description: MISSING[str] = UNSET,
    ) -> "Response[Label]":
        ...

    def create_label(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoLabelsPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Label,
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    @overload
    async def async_create_label(
        self, owner: str, repo: str, *, data: ReposOwnerRepoLabelsPostBodyType
    ) -> "Response[Label]":
        ...

    @overload
    async def async_create_label(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        name: str,
        color: MISSING[str] = UNSET,
        description: MISSING[str] = UNSET,
    ) -> "Response[Label]":
        ...

    async def async_create_label(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoLabelsPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Label,
            error_models={
                "422": ValidationError,
                "404": BasicError,
            },
        )

    def get_label(
        self,
        owner: str,
        repo: str,
        name: str,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Label,
            error_models={
                "404": BasicError,
            },
        )

    async def async_get_label(
        self,
        owner: str,
        repo: str,
        name: str,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Label,
            error_models={
                "404": BasicError,
            },
        )

    def delete_label(
        self,
        owner: str,
        repo: str,
        name: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    async def async_delete_label(
        self,
        owner: str,
        repo: str,
        name: str,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
        )

    @overload
    def update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsNamePatchBodyType] = UNSET,
    ) -> "Response[Label]":
        ...

    @overload
    def update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: Literal[UNSET] = UNSET,
        new_name: MISSING[str] = UNSET,
        color: MISSING[str] = UNSET,
        description: MISSING[str] = UNSET,
    ) -> "Response[Label]":
        ...

    def update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsNamePatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoLabelsNamePatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Label,
        )

    @overload
    async def async_update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsNamePatchBodyType] = UNSET,
    ) -> "Response[Label]":
        ...

    @overload
    async def async_update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: Literal[UNSET] = UNSET,
        new_name: MISSING[str] = UNSET,
        color: MISSING[str] = UNSET,
        description: MISSING[str] = UNSET,
    ) -> "Response[Label]":
        ...

    async def async_update_label(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        data: MISSING[ReposOwnerRepoLabelsNamePatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Label]":
        url = f"/repos/{owner}/{repo}/labels/{name}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoLabelsNamePatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Label,
        )

    def list_milestones(
        self,
        owner: str,
        repo: str,
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        sort: MISSING[Literal["due_on", "completeness"]] = "due_on",
        direction: MISSING[Literal["asc", "desc"]] = "asc",
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Milestone]]":
        url = f"/repos/{owner}/{repo}/milestones"

        params = {
            "state": state,
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Milestone],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_milestones(
        self,
        owner: str,
        repo: str,
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        sort: MISSING[Literal["due_on", "completeness"]] = "due_on",
        direction: MISSING[Literal["asc", "desc"]] = "asc",
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Milestone]]":
        url = f"/repos/{owner}/{repo}/milestones"

        params = {
            "state": state,
            "sort": sort,
            "direction": direction,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Milestone],
            error_models={
                "404": BasicError,
            },
        )

    @overload
    def create_milestone(
        self, owner: str, repo: str, *, data: ReposOwnerRepoMilestonesPostBodyType
    ) -> "Response[Milestone]":
        ...

    @overload
    def create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        title: str,
        state: MISSING[Literal["open", "closed"]] = "open",
        description: MISSING[str] = UNSET,
        due_on: MISSING[datetime] = UNSET,
    ) -> "Response[Milestone]":
        ...

    def create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoMilestonesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoMilestonesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Milestone,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_create_milestone(
        self, owner: str, repo: str, *, data: ReposOwnerRepoMilestonesPostBodyType
    ) -> "Response[Milestone]":
        ...

    @overload
    async def async_create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        data: Literal[UNSET] = UNSET,
        title: str,
        state: MISSING[Literal["open", "closed"]] = "open",
        description: MISSING[str] = UNSET,
        due_on: MISSING[datetime] = UNSET,
    ) -> "Response[Milestone]":
        ...

    async def async_create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        data: MISSING[ReposOwnerRepoMilestonesPostBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoMilestonesPostBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Milestone,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    def get_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Milestone,
            error_models={
                "404": BasicError,
            },
        )

    async def async_get_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Milestone,
            error_models={
                "404": BasicError,
            },
        )

    def delete_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_delete_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
    ) -> "Response":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    @overload
    def update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: MISSING[ReposOwnerRepoMilestonesMilestoneNumberPatchBodyType] = UNSET,
    ) -> "Response[Milestone]":
        ...

    @overload
    def update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        title: MISSING[str] = UNSET,
        state: MISSING[Literal["open", "closed"]] = "open",
        description: MISSING[str] = UNSET,
        due_on: MISSING[datetime] = UNSET,
    ) -> "Response[Milestone]":
        ...

    def update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: MISSING[ReposOwnerRepoMilestonesMilestoneNumberPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoMilestonesMilestoneNumberPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Milestone,
        )

    @overload
    async def async_update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: MISSING[ReposOwnerRepoMilestonesMilestoneNumberPatchBodyType] = UNSET,
    ) -> "Response[Milestone]":
        ...

    @overload
    async def async_update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: Literal[UNSET] = UNSET,
        title: MISSING[str] = UNSET,
        state: MISSING[Literal["open", "closed"]] = "open",
        description: MISSING[str] = UNSET,
        due_on: MISSING[datetime] = UNSET,
    ) -> "Response[Milestone]":
        ...

    async def async_update_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        *,
        data: MISSING[ReposOwnerRepoMilestonesMilestoneNumberPatchBodyType] = UNSET,
        **kwargs,
    ) -> "Response[Milestone]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}"

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(ReposOwnerRepoMilestonesMilestoneNumberPatchBody, json)
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Milestone,
        )

    def list_labels_for_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
        )

    async def async_list_labels_for_milestone(
        self,
        owner: str,
        repo: str,
        milestone_number: int,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Label]]":
        url = f"/repos/{owner}/{repo}/milestones/{milestone_number}/labels"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Label],
        )

    def list_for_authenticated_user(
        self,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = "/user/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_for_authenticated_user(
        self,
        filter_: MISSING[
            Literal["assigned", "created", "mentioned", "subscribed", "repos", "all"]
        ] = "assigned",
        state: MISSING[Literal["open", "closed", "all"]] = "open",
        labels: MISSING[str] = UNSET,
        sort: MISSING[Literal["created", "updated", "comments"]] = "created",
        direction: MISSING[Literal["asc", "desc"]] = "desc",
        since: MISSING[datetime] = UNSET,
        per_page: MISSING[int] = 30,
        page: MISSING[int] = 1,
    ) -> "Response[List[Issue]]":
        url = "/user/issues"

        params = {
            "filter": filter_,
            "state": state,
            "labels": labels,
            "sort": sort,
            "direction": direction,
            "since": since,
            "per_page": per_page,
            "page": page,
        }

        headers = {
            "X-GitHub-Api-Version": self._REST_API_VERSION,
        }

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=List[Issue],
            error_models={
                "404": BasicError,
            },
        )
