"""DO NOT EDIT THIS FILE!

This file is automatically @generated by githubkit using the follow command:

bash ./scripts/run-codegen.sh

See https://github.com/github/rest-api-description for more information.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Literal, Optional, overload
from weakref import ref

from pydantic import BaseModel

from githubkit.compat import model_dump, type_validate_python
from githubkit.typing import Missing, UnsetType
from githubkit.utils import UNSET, exclude_unset

if TYPE_CHECKING:
    from typing import Literal, Union

    from githubkit import GitHubCore
    from githubkit.response import Response
    from githubkit.typing import Missing
    from githubkit.utils import UNSET

    from ..models import (
        Import,
        Migration,
        MinimalRepository,
        PorterAuthor,
        PorterLargeFile,
    )
    from ..types import (
        ImportType,
        MigrationType,
        MinimalRepositoryType,
        OrgsOrgMigrationsPostBodyType,
        PorterAuthorType,
        PorterLargeFileType,
        ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType,
        ReposOwnerRepoImportLfsPatchBodyType,
        ReposOwnerRepoImportPatchBodyType,
        ReposOwnerRepoImportPutBodyType,
        UserMigrationsPostBodyType,
    )


class MigrationsClient:
    _REST_API_VERSION = "2022-11-28"

    def __init__(self, github: GitHubCore):
        self._github_ref = ref(github)

    @property
    def _github(self) -> GitHubCore:
        if g := self._github_ref():
            return g
        raise RuntimeError(
            "GitHub client has already been collected. "
            "Do not use this client after the client has been collected."
        )

    def list_for_org(
        self,
        org: str,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[Migration], list[MigrationType]]:
        """See also: https://docs.github.com/rest/migrations/orgs#list-organization-migrations"""

        from ..models import Migration

        url = f"/orgs/{org}/migrations"

        params = {
            "per_page": per_page,
            "page": page,
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[Migration],
        )

    async def async_list_for_org(
        self,
        org: str,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[Migration], list[MigrationType]]:
        """See also: https://docs.github.com/rest/migrations/orgs#list-organization-migrations"""

        from ..models import Migration

        url = f"/orgs/{org}/migrations"

        params = {
            "per_page": per_page,
            "page": page,
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[Migration],
        )

    @overload
    def start_for_org(
        self,
        org: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: OrgsOrgMigrationsPostBodyType,
    ) -> Response[Migration, MigrationType]: ...

    @overload
    def start_for_org(
        self,
        org: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        repositories: list[str],
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
    ) -> Response[Migration, MigrationType]: ...

    def start_for_org(
        self,
        org: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[OrgsOrgMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/orgs#start-an-organization-migration"""

        from ..models import (
            BasicError,
            Migration,
            OrgsOrgMigrationsPostBody,
            ValidationError,
        )

        url = f"/orgs/{org}/migrations"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(OrgsOrgMigrationsPostBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    @overload
    async def async_start_for_org(
        self,
        org: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: OrgsOrgMigrationsPostBodyType,
    ) -> Response[Migration, MigrationType]: ...

    @overload
    async def async_start_for_org(
        self,
        org: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        repositories: list[str],
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
    ) -> Response[Migration, MigrationType]: ...

    async def async_start_for_org(
        self,
        org: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[OrgsOrgMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/orgs#start-an-organization-migration"""

        from ..models import (
            BasicError,
            Migration,
            OrgsOrgMigrationsPostBody,
            ValidationError,
        )

        url = f"/orgs/{org}/migrations"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(OrgsOrgMigrationsPostBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "422": ValidationError,
            },
        )

    def get_status_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/orgs#get-an-organization-migration-status"""

        from ..models import BasicError, Migration

        url = f"/orgs/{org}/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
            },
        )

    async def async_get_status_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/orgs#get-an-organization-migration-status"""

        from ..models import BasicError, Migration

        url = f"/orgs/{org}/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
            },
        )

    def download_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#download-an-organization-migration-archive"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_download_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#download-an-organization-migration-archive"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def delete_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#delete-an-organization-migration-archive"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_delete_archive_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#delete-an-organization-migration-archive"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def unlock_repo_for_org(
        self,
        org: str,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#unlock-an-organization-repository"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    async def async_unlock_repo_for_org(
        self,
        org: str,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/orgs#unlock-an-organization-repository"""

        from ..models import BasicError

        url = f"/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
            },
        )

    def list_repos_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[MinimalRepository], list[MinimalRepositoryType]]:
        """See also: https://docs.github.com/rest/migrations/orgs#list-repositories-in-an-organization-migration"""

        from ..models import BasicError, MinimalRepository

        url = f"/orgs/{org}/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_repos_for_org(
        self,
        org: str,
        migration_id: int,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[MinimalRepository], list[MinimalRepositoryType]]:
        """See also: https://docs.github.com/rest/migrations/orgs#list-repositories-in-an-organization-migration"""

        from ..models import BasicError, MinimalRepository

        url = f"/orgs/{org}/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    def get_import_status(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-an-import-status"""

        from ..models import BasicError, Import

        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    async def async_get_import_status(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-an-import-status"""

        from ..models import BasicError, Import

        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: ReposOwnerRepoImportPutBodyType,
    ) -> Response[Import, ImportType]: ...

    @overload
    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        vcs_url: str,
        vcs: Missing[Literal["subversion", "git", "mercurial", "tfvc"]] = UNSET,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> Response[Import, ImportType]: ...

    def start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportPutBodyType] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#start-an-import"""

        from ..models import (
            BasicError,
            Import,
            ReposOwnerRepoImportPutBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(ReposOwnerRepoImportPutBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: ReposOwnerRepoImportPutBodyType,
    ) -> Response[Import, ImportType]: ...

    @overload
    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        vcs_url: str,
        vcs: Missing[Literal["subversion", "git", "mercurial", "tfvc"]] = UNSET,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> Response[Import, ImportType]: ...

    async def async_start_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportPutBodyType] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#start-an-import"""

        from ..models import (
            BasicError,
            Import,
            ReposOwnerRepoImportPutBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(ReposOwnerRepoImportPutBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PUT",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    def cancel_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/source-imports#cancel-an-import"""

        from ..models import BasicError

        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "503": BasicError,
            },
        )

    async def async_cancel_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/source-imports#cancel-an-import"""

        from ..models import BasicError

        url = f"/repos/{owner}/{repo}/import"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "503": BasicError,
            },
        )

    @overload
    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
    ) -> Response[Import, ImportType]: ...

    @overload
    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        vcs: Missing[Literal["subversion", "tfvc", "git", "mercurial"]] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> Response[Import, ImportType]: ...

    def update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#update-an-import"""

        from typing import Union

        from ..models import BasicError, Import, ReposOwnerRepoImportPatchBody

        url = f"/repos/{owner}/{repo}/import"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(
                Union[ReposOwnerRepoImportPatchBody, None], json
            )
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "503": BasicError,
            },
        )

    @overload
    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
    ) -> Response[Import, ImportType]: ...

    @overload
    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        vcs_username: Missing[str] = UNSET,
        vcs_password: Missing[str] = UNSET,
        vcs: Missing[Literal["subversion", "tfvc", "git", "mercurial"]] = UNSET,
        tfvc_project: Missing[str] = UNSET,
    ) -> Response[Import, ImportType]: ...

    async def async_update_import(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[Union[ReposOwnerRepoImportPatchBodyType, None]] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#update-an-import"""

        from typing import Union

        from ..models import BasicError, Import, ReposOwnerRepoImportPatchBody

        url = f"/repos/{owner}/{repo}/import"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(
                Union[ReposOwnerRepoImportPatchBody, None], json
            )
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "503": BasicError,
            },
        )

    def get_commit_authors(
        self,
        owner: str,
        repo: str,
        *,
        since: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[PorterAuthor], list[PorterAuthorType]]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-commit-authors"""

        from ..models import BasicError, PorterAuthor

        url = f"/repos/{owner}/{repo}/import/authors"

        params = {
            "since": since,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[PorterAuthor],
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    async def async_get_commit_authors(
        self,
        owner: str,
        repo: str,
        *,
        since: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[PorterAuthor], list[PorterAuthorType]]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-commit-authors"""

        from ..models import BasicError, PorterAuthor

        url = f"/repos/{owner}/{repo}/import/authors"

        params = {
            "since": since,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[PorterAuthor],
            error_models={
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
    ) -> Response[PorterAuthor, PorterAuthorType]: ...

    @overload
    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        email: Missing[str] = UNSET,
        name: Missing[str] = UNSET,
    ) -> Response[PorterAuthor, PorterAuthorType]: ...

    def map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> Response[PorterAuthor, PorterAuthorType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"""

        from ..models import (
            BasicError,
            PorterAuthor,
            ReposOwnerRepoImportAuthorsAuthorIdPatchBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import/authors/{author_id}"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(
                ReposOwnerRepoImportAuthorsAuthorIdPatchBody, json
            )
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=PorterAuthor,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    @overload
    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
    ) -> Response[PorterAuthor, PorterAuthorType]: ...

    @overload
    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        email: Missing[str] = UNSET,
        name: Missing[str] = UNSET,
    ) -> Response[PorterAuthor, PorterAuthorType]: ...

    async def async_map_commit_author(
        self,
        owner: str,
        repo: str,
        author_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportAuthorsAuthorIdPatchBodyType] = UNSET,
        **kwargs,
    ) -> Response[PorterAuthor, PorterAuthorType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"""

        from ..models import (
            BasicError,
            PorterAuthor,
            ReposOwnerRepoImportAuthorsAuthorIdPatchBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import/authors/{author_id}"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(
                ReposOwnerRepoImportAuthorsAuthorIdPatchBody, json
            )
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=PorterAuthor,
            error_models={
                "422": ValidationError,
                "404": BasicError,
                "503": BasicError,
            },
        )

    def get_large_files(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[PorterLargeFile], list[PorterLargeFileType]]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-large-files"""

        from ..models import BasicError, PorterLargeFile

        url = f"/repos/{owner}/{repo}/import/large_files"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=list[PorterLargeFile],
            error_models={
                "503": BasicError,
            },
        )

    async def async_get_large_files(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[PorterLargeFile], list[PorterLargeFileType]]:
        """See also: https://docs.github.com/rest/migrations/source-imports#get-large-files"""

        from ..models import BasicError, PorterLargeFile

        url = f"/repos/{owner}/{repo}/import/large_files"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            response_model=list[PorterLargeFile],
            error_models={
                "503": BasicError,
            },
        )

    @overload
    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: ReposOwnerRepoImportLfsPatchBodyType,
    ) -> Response[Import, ImportType]: ...

    @overload
    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        use_lfs: Literal["opt_in", "opt_out"],
    ) -> Response[Import, ImportType]: ...

    def set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportLfsPatchBodyType] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"""

        from ..models import (
            BasicError,
            Import,
            ReposOwnerRepoImportLfsPatchBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import/lfs"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(ReposOwnerRepoImportLfsPatchBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "503": BasicError,
            },
        )

    @overload
    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: ReposOwnerRepoImportLfsPatchBodyType,
    ) -> Response[Import, ImportType]: ...

    @overload
    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        use_lfs: Literal["opt_in", "opt_out"],
    ) -> Response[Import, ImportType]: ...

    async def async_set_lfs_preference(
        self,
        owner: str,
        repo: str,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[ReposOwnerRepoImportLfsPatchBodyType] = UNSET,
        **kwargs,
    ) -> Response[Import, ImportType]:
        """See also: https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"""

        from ..models import (
            BasicError,
            Import,
            ReposOwnerRepoImportLfsPatchBody,
            ValidationError,
        )

        url = f"/repos/{owner}/{repo}/import/lfs"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(ReposOwnerRepoImportLfsPatchBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "PATCH",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Import,
            error_models={
                "422": ValidationError,
                "503": BasicError,
            },
        )

    def list_for_authenticated_user(
        self,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[Migration], list[MigrationType]]:
        """See also: https://docs.github.com/rest/migrations/users#list-user-migrations"""

        from ..models import BasicError, Migration

        url = "/user/migrations"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[Migration],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_list_for_authenticated_user(
        self,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[Migration], list[MigrationType]]:
        """See also: https://docs.github.com/rest/migrations/users#list-user-migrations"""

        from ..models import BasicError, Migration

        url = "/user/migrations"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[Migration],
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    def start_for_authenticated_user(
        self,
        *,
        headers: Optional[dict[str, str]] = None,
        data: UserMigrationsPostBodyType,
    ) -> Response[Migration, MigrationType]: ...

    @overload
    def start_for_authenticated_user(
        self,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        repositories: list[str],
    ) -> Response[Migration, MigrationType]: ...

    def start_for_authenticated_user(
        self,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[UserMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/users#start-a-user-migration"""

        from ..models import (
            BasicError,
            Migration,
            UserMigrationsPostBody,
            ValidationError,
        )

        url = "/user/migrations"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(UserMigrationsPostBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return self._github.request(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "422": ValidationError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    @overload
    async def async_start_for_authenticated_user(
        self,
        *,
        headers: Optional[dict[str, str]] = None,
        data: UserMigrationsPostBodyType,
    ) -> Response[Migration, MigrationType]: ...

    @overload
    async def async_start_for_authenticated_user(
        self,
        *,
        data: UnsetType = UNSET,
        headers: Optional[dict[str, str]] = None,
        lock_repositories: Missing[bool] = UNSET,
        exclude_metadata: Missing[bool] = UNSET,
        exclude_git_data: Missing[bool] = UNSET,
        exclude_attachments: Missing[bool] = UNSET,
        exclude_releases: Missing[bool] = UNSET,
        exclude_owner_projects: Missing[bool] = UNSET,
        org_metadata_only: Missing[bool] = UNSET,
        exclude: Missing[list[Literal["repositories"]]] = UNSET,
        repositories: list[str],
    ) -> Response[Migration, MigrationType]: ...

    async def async_start_for_authenticated_user(
        self,
        *,
        headers: Optional[dict[str, str]] = None,
        data: Missing[UserMigrationsPostBodyType] = UNSET,
        **kwargs,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/users#start-a-user-migration"""

        from ..models import (
            BasicError,
            Migration,
            UserMigrationsPostBody,
            ValidationError,
        )

        url = "/user/migrations"

        headers = {
            "Content-Type": "application/json",
            "X-GitHub-Api-Version": self._REST_API_VERSION,
            **(headers or {}),
        }

        json = kwargs if data is UNSET else data
        if self._github.config.rest_api_validate_body:
            json = type_validate_python(UserMigrationsPostBody, json)
        json = model_dump(json) if isinstance(json, BaseModel) else json

        return await self._github.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "422": ValidationError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def get_status_for_authenticated_user(
        self,
        migration_id: int,
        *,
        exclude: Missing[list[str]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/users#get-a-user-migration-status"""

        from ..models import BasicError, Migration

        url = f"/user/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_status_for_authenticated_user(
        self,
        migration_id: int,
        *,
        exclude: Missing[list[str]] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[Migration, MigrationType]:
        """See also: https://docs.github.com/rest/migrations/users#get-a-user-migration-status"""

        from ..models import BasicError, Migration

        url = f"/user/migrations/{migration_id}"

        params = {
            "exclude": exclude,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=Migration,
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def get_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#download-a-user-migration-archive"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_get_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#download-a-user-migration-archive"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            headers=exclude_unset(headers),
            error_models={
                "403": BasicError,
                "401": BasicError,
            },
        )

    def delete_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#delete-a-user-migration-archive"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_delete_archive_for_authenticated_user(
        self,
        migration_id: int,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#delete-a-user-migration-archive"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/archive"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def unlock_repo_for_authenticated_user(
        self,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#unlock-a-user-repository"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    async def async_unlock_repo_for_authenticated_user(
        self,
        migration_id: int,
        repo_name: str,
        *,
        headers: Optional[dict[str, str]] = None,
    ) -> Response:
        """See also: https://docs.github.com/rest/migrations/users#unlock-a-user-repository"""

        from ..models import BasicError

        url = f"/user/migrations/{migration_id}/repos/{repo_name}/lock"

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "DELETE",
            url,
            headers=exclude_unset(headers),
            error_models={
                "404": BasicError,
                "403": BasicError,
                "401": BasicError,
            },
        )

    def list_repos_for_authenticated_user(
        self,
        migration_id: int,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[MinimalRepository], list[MinimalRepositoryType]]:
        """See also: https://docs.github.com/rest/migrations/users#list-repositories-for-a-user-migration"""

        from ..models import BasicError, MinimalRepository

        url = f"/user/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return self._github.request(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )

    async def async_list_repos_for_authenticated_user(
        self,
        migration_id: int,
        *,
        per_page: Missing[int] = UNSET,
        page: Missing[int] = UNSET,
        headers: Optional[dict[str, str]] = None,
    ) -> Response[list[MinimalRepository], list[MinimalRepositoryType]]:
        """See also: https://docs.github.com/rest/migrations/users#list-repositories-for-a-user-migration"""

        from ..models import BasicError, MinimalRepository

        url = f"/user/migrations/{migration_id}/repositories"

        params = {
            "per_page": per_page,
            "page": page,
        }

        headers = {"X-GitHub-Api-Version": self._REST_API_VERSION, **(headers or {})}

        return await self._github.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=list[MinimalRepository],
            error_models={
                "404": BasicError,
            },
        )
